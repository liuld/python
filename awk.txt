							      AWK
AWK是一种优良的文本处理工具。它不仅是 Linux 中也是任何环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母）的最大功能取决于一个人所拥有的知识。AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。实际上 AWK 的确拥有自己的语言：AWK 程序设计语言， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。
最简单地说， AWK 是一种用于处理文本的编程语言工具。AWK 在很多方面类似于 shell 编程语言，尽管 AWK 具有完全属于其本身的语法。它的设计思想来源于 SNOBOL4 、sed 、Marc Rochkind设计的有效性语言、语言工具 yacc 和 lex ，当然还从 C 语言中获取了一些优秀的思想。在最初创造 AWK 时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。

我们常用sed和awk相结合的方式处理文本sed|awk的方式能让我们的处理命令更快捷,提高工作效率

awk语法 
awk [options] ‘commands’ files

option

-F 定义字段分隔符,默认的分隔符是连续的空格或制表符
如:
aaaa   bbbb
aaa bb 
ccc       dd
awk ‘{print $1}’a.txt
awk -F: ‘{print $1}’/etc/passwd
用$1,$2,$3等的顺序表示files中每行以间隔符号分隔的各列不同域.$0代表整行
如:
awk ‘{print $1,$2,$0}’a.txt
NF变量表示当前记录的字段数
如:
awk -F: ‘{print NF}’/etc/passwd
awk -F: ‘{print $NF}’/etc/passwd

-v可以借用此方式从shell变量中引入
command
读前处理  行处理   读后处理
1. 读前处理BEGIN{awk_cmd1;awk_cmd2}
如:
awk 'BEGIN {print "hello,World"}'
awk 'BEGIN{print "start handle file"}{print}END{print"stop handle file"}' /etc/passwd


练习:
先输出 开始处理文件
取当前系统所有用户的名字 uid  和 shell   
最后输出 处理完毕


2. 行处理:定址命令
定址方法: 正则,变量,比较和关系运算
正则需要用//包围起来
awk -F: '/root/{print}' /etc/passwd
awk -F: '$1~/root/{print}' /etc/passwd
awk -F: '$1!~/root/{print}' /etc/passwd
^ 行首
$ 行尾
. 除了换行符以外的任意单个字符
* 前导字符的零个或多个
.* 所有字符
[] 字符组内的任一字符
[^]对字符组内的每个字符取反(不匹配字符组内的每个字符)
^[^] 非字符组内的字符开头的行
[a-z] 小写字母
[A-Z] 大写字母
[a-Z] 小写和大写字母
[0-9] 数字
\< 单词头单词一般以空格或特殊字符做分隔,连续的字符串被当做单词
\> 单词尾

NR变量定址
NR 表示AWK读入的行数
FNR表示读入行所在文件中的行数
# awk '{print NR,FNR,$1}' file1 file2
1 1 aaaaa
2 2 bbbbb
3 3 ccccc
4 1 dddddd
5 2 eeeeee
6 3 ffffff


逻辑运算可直接引用域进行运算
== >= <= != > <
# awk 'NR==1 {print}' /etc/passwd
root:x:0:0:root:/root:/bin/bash

3.命令{print $0}
4.读后处理END {awk_cmd1;awk_cmd2;}

例子:
cat 2.txt | head -2
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin

awk –F”:”‘{print $1,$6}’2.txt | head -2
root /root
bin /bin
awk –F“:” ‘{print $1”\t\t”$6}’ 2.txt|head -2
root	/root
bin		/bin
awk –F”:”	‘BEGIN{print “用户名\t\t家目录”}{print $1”\t\t”$6}’2.txt| head -2
例2:cat 1.txt
mona 70 77 85 83 70 89
john 85 92 78 94 88 91
andrea 89 90 85 94 90 95
jasper 84 88 80 92 84 82
dunce 6 80 60 60 61 62
ellis 5 98 89 96 96 92

awk 'BEGIN{print "\t\t某某班14暑假成绩";print "学员\t数学\t语文\t英语\t化学\t物理\t历史"}{print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7}END{print "年级排名请查询数据库"}' test3.txt l

awk 'BEGIN{OFS="\t";print "\t\t某某班14暑假成绩";print "学 员\t数学\t语文\t英语\t化学\t物理\t历史"}{print $1,$2,$3,$4,$5,$6,$7}END{print "年级排名请查询数据库"}' test3.txt

awk ‘{print $0}’1.txt
awk ‘$2~/6/{print $0}’1.txt
awk  ‘$2>=6{print $0}’1.txt

操作符
赋值= ++ -- += -= /= *= 
++ Add 1 to variable.
awk 'BEGIN{a=1;a++;print a}'  打印值为2
awk 'BEGIN{a=1;++a;print a}'  打印值为2 先加1在执行命令
awk 'BEGIN{a=1;print a++;print a}' 先执行命令然后a+1
a=1命令先执行a还=1,最后在打印a=2

-- Subtract 1 from variable. awk '
BEGIN{a=1;a--;print a}' 打印值为0

+= Assign result of addition.
awk 'BEGIN{a=1;b=a+5;print b}'  给b赋值
awk 'BEGIN{a=1;a=a+5;print a}'  给自己赋值
awk 'BEGIN{a=1;a+=5;print a}'  上条命令简化写法

-= Assign result of subtraction.
awk 'BEGIN{a=1;a-=5;print a}'  a-5在赋值给a 以下相同
awk 'BEGIN{a=1;a-=5.2;print a}' 支持小数运算
*= Assign result of multiplication.
/= Assign result of division.
%= Assign result of modulo.
^= Assign result of exponentiation


|| Logical OR  逻辑 两边任意一边成立
&& Logical AND 逻辑与 两边成立  前边如果假值后边就不做了
! Logical NOT  逻辑取反 原本真值变成假值
例如:
awk '$1~/root/||NR>40{print}' /etc/passwd
awk '$1~/root/&&NR<2{print}' /etc/passwd


匹配正则或不匹配,正则需要用/正则/ 包围住
~     !~

关系比较字符串时要把字符串用双引号引起来
< <= > >= != ==


字段引用
$ 字段引用需要加$,而变量引用直接用变量名取
运算符+ - * / % ++ --


转义序列
\\ \自身
\$ 转义$
\t 制表符
\b 退格符
\r 回车符
\n 换行符
\c 取消换行

awk引用shell变量
a=root
awk –v var=$a –F“:” ’$1==var{print $0}’ /etc/passwd

内置变量

FS 定义字段分隔符,默认为一个空格
OFS 输出的字段分隔符，默认为一个空格
awk 'BEGIN{ FS=":";OFS="-" }{ print $1,$3,$5 }' /etc/passwd  | head -2
awk 'BEGIN{ FS=":";OFS="-" }{ print $1”@@”$3”##”$5 }' /etc/passwd  | head -2  自己定义
RS 记录分隔符，默认为一个换行符
head -2 /etc/passwd | awk 'BEGIN{ RS=":"}{print}'
ORS 输出的记录分隔符，默认为一个换行符
head -2 /etc/passwd | awk 'BEGIN{ ORS="-"}{print}'
NR 行数(如两个文件一个5行 1个10行 输出为15行)
awk  '{print NR}' aa.txt cc.txt
FNR 行数，多文件操作时会重新排序(如两个文件一个5行,一个10行 输出为5 10) awk  '{print FNR}' aa.txt cc.txt
NF 输出当前输入记录的编号（字段的个数）
aaaa bbb ccc
cccc bbb
aaa ccc bb  nn
awk '{ print NF}' aa.txt
FILENAME 文件名
ARGC 命令行参数个数
ARGV 命令行参数排列
ENVIRON 输出系统环境变量

例子:
cat awk.txt
aaa#123
asdf:234
haha:456

awk –F’#’ ’{print NR,$0,NF,FILENAME }’awk.txt
1 aaaa#123 2 awk.sh
2 asdf:234 1 awk.sh
3 haha:456 1 awk.sh
4  0 awk.sh

awk -F"#" '{ print ARGC,ARGV[0],ARGV[1]}' awk.sh.txt
2 awk awk.sh.txt
2 awk awk.sh.txt
2 awk awk.sh.txt
2 awk awk.sh.txt

awk -F"#" '{ print NR,$0,NF,$1,$2 }' awk.sh.txt
1 aaaa#123 2 aaaa 123
2 asdf:234 1 asdf:234
3 haha:456 1 haha:456
4  0

awk 'BEGIN{print ENVIRON["USER"]}'


练习题:
1打印uid在30~40范围内的用户名
awk -F: '$3>=30&&$3<=40{print $1,$3}' /etc/passwd
2打印第5-10行的行号和用户名
awk -F: 'NR>=5&&NR<=10{print $1,NR}' /etc/passwd
3 打印奇数行
awk -F: 'NR%2==1{print NR,$0}' /etc/passwd
4 打印偶数行
awk -F: 'NR%2==0{print NR,$0}' /etc/passwd
5 打印字段数大于5的行
awk -F: 'NF>5{print $0}' /etc/passwd
6打印UID不等于GID的用户名
awk -F: '$3!=$4{print $0}' /etc/passwd
7.打印1..100以内的7的倍数和包含7的数
seq 1 100 | awk '$1~/7/||$1%7==0{print $1}'
8.计算UID相加的总和;计算GID相加的总和
awk -F: '{uid+=$3;gid+=$4}END{print uid;print gid}' /etc/passwd
9.计算VSZ和RSS各自的和 并以M单位显示
ps aux|awk 'NR>1{vsz+=$5;rss+=$6}END{print vsz/1024"M";print rss/1024"M"}'


流程控制:
分支结构
一. if (条件) 动作
若有多个动作,则要用大括号将动作体包含起来if (条件) {动作1;动作2}

# awk -F : '{if ($1 == "root") print $1}' /etc/passwd
# awk -F: '{if ($1 == "root") {print $1;print $6} }' /etc/passwd

二. if(条件1)
    动作1
else
    动作2

# awk -F: '{if ($1 == "root"){print $1}else print $6}' /etc/passwd
# awk -F: '{if ($1 == "root") print $1;else print $6}' /etc/passwd
上面两个命令是等价的,要么用分号隔开,表示第一个动作体的结束,要么将动作体用大括号定位范围

三.
if (条件1)
动作1
else if(条件2)
动作2
else if(条件3)
动作3
else
动作
awk -F: '{if ($1 == "root") print $1;else if ($1 == "seker") print $6;else if ($1 == "zorro") print $7;else printNR}' /etc/passwd


读前处理和读后处理
# awk -F: 'BEGIN {print NR,NF}' /etc/passwd
0 0
# awk -F: 'END {print NR,NF}' /etc/passwd
46 7
# awk -F: 'BEGIN{i=1} {i++} END {print i}' /etc/passwd
47

练习:找出普通用户的用户名并统计数量
[root@manager test7]# awk -F: '{if($3>=500) sum+=1}END{print sum}' /etc/passwd
将系统用户按UID分组标记 0 admin; 1-499 sysuser; 500+ users
用户名  uid   权限
root   0     admin
ftp    21    sysuser
robin  500   users
[root@manager test7]# awk 'BEGIN{FS=":";OFS="\t";print "用户名\tUID\t权限"}{if($3==0)print $1,$3,"admin";else if($3<500)print $1,$3,"sysusers";else print $1,$3,"users"}' /etc/passwd




循环语句
while(条件) {
动作
条件运算

awk -F: '{while($3<3) {print $3,$1;$3++}}' /etc/passwd


BEGIN块可以独立使用,不需要引入文件
# awk 'BEGIN{i=1;while(i<100) {print i;i++}}'

练习 打印100以内的偶数
awk 'BEGIN{i=1;while(i<100){if(i%2==0)print i;i++}}'


x=1
do {
动作1
x++
} while (x<5)
# awk 'BEGIN{i=5;do{print i;i++}while(i<10)}'
# awk 'BEGIN{i=5;do{print i;i++}while(i<1)}'


for(预置;条件;递增) {
动作
}
# awk 'BEGIN {for (x=1;x<=4;x++) print x }'


练习:
逆序输出每个字段
	达到这样既可
	/bin/bash
	/root
	root
	0
	0
	x
	root

awk -F: 'BEGIN{printf "%-15s %-15s %-15s\n","用户名","UID","权限"}{if ($3==0) printf "%-18s %-15s %-15s\n",$1,$3,"admin";else if($3<500) printf "%-18s %-15s %-15s\n",$1,$3,"sysuser";else printf "%-18s %-15s %-15s\n",$1,$3,"users"}' /etc/passw



跳转语句
break 跳出循环
# awk 'BEGIN {for(x=1;x<5;x++) {if (x==3) break;print x }}'
1
2

continue 在达到循环底部之前终止当前循环从新开始下一次循环
# awk 'BEGIN {for(x=1;x<5;x++) {if (x==3) continue;print x }}'
1
2
4

next 读入下一行同时返回脚本顶部这样可以避免对当前行执行其他操作
# awk -F: 'NR > 5 {next} {print $1} END {print NR}' /etc/passwd
root
bin
daemon
adm
lp




cat -b u.txt
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
4 adm:x:3:4:adm:/var/adm:/sbin/nologin
5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
8 halt:x:7:0:halt:/sbin:/sbin/halt
9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
10 news:x:9:13:news:/etc/news:

awk -F: 'BEGIN{i=1}NR>5 {next}{print i++}END{print NR}' u.txt
1
2
3
4
5
10

awk -F: 'BEGIN{i=1}NR>5 {exit}{print i++}END{print NR}' u.txt
1
2
3
4
5

数组
自定义数组
# awk 'BEGIN {ary[1]="seker";ary[2]="zorro";print ary[1],ary[2]}'
seker zorro
# awk 'BEGIN {ary[1]="seker";ary[2]="zorro";for(i in ary) print ary[i]}'
seker
zorro

循环产生数组和取出数组
# awk 'BEGIN{n=5;for (i=1;i<=n;i++) ary[i]=i+100;for(m in ary) print m,ary[m]}'
4 104
5 105
1 101
2 102
3 103


awk -F: '{ary[NR]=$1} END {for(i in ary) print i,ary[i]}' /etc/passwd
1 root
2 bin
3 daemon
4 adm
5 lp
6 sync
7 shutdown
8 halt
9 mail


awk -F: '{ary[$3]=$1} END {for(i in ary) print i,ary[i]}' /etc/passwd
10 uucp
11 operator
12 games
13 gopher
14 ftp
32 rpc
37 rpm


利用数组实现行列互换?
如
[root@manager ~]# cat aa.txt 
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5

1 1 1 1 1 
2 2 2 2 2 
3 3 3 3 3 
4 4 4 4 4 
5 5 5 5 5

[root@manager test7]# awk '{for(i=1;i<=NF;i++) ary[NR,i]=$i}END{for(j=1;j<=NF;j++){for(l=1;l<=NR;l++)printf ary[l,j]" ";printf "\n"}}' kk.txt





awk的内置函数
一.算数函数
sqrt函数(求平方根)
[root@manager ~]# awk 'BEGIN{x=sqrt(100);print x}'
10

[root@manager ~]# awk 'BEGIN{x=int(3.14);print x}'
3
[root@manager ~]# awk 'BEGIN{x=int(3.88);print x}'
3

rand函数(内置函数 srand 使用参数awk 'BEGIN{x=rand();print x}'作为随机数种子。当参数缺省的时候，使用当前时间作为随机数种子。)
[root@manager ~]# awk 'BEGIN{x=rand();print x}'
0.237788

srand函数(内置函数 rand 的伪随机函数，其返回值范围为  0 >= result <= 1。在实际使用时，一般先使用 srand 函数生成随机数种子，然后再使用 rand 函数生成随机数。否则每次得到的值会一样。)
[root@manager ~]# awk 'BEGIN{srand();x=int(100*rand());print x}'
64
[root@manager ~]# awk 'BEGIN{srand();x=int(100*rand());print x}'
32
[root@manager ~]# awk 'BEGIN{srand();x=int(100*rand());print x}'
60


二.字符串函数
sub和gsub函数使用(替换字符)
[root@manager ~]# awk 'BEGIN{info="this is a test2010test2010test!";sub(2010,"!",info);print info}'
this is a test!test2010test!

[root@manager ~]# awk 'BEGIN{info="this is a test2010test2010test!";gsub(2010,"!",info);print info}'
this is a test!test!test!

index函数(查找字符)
[root@manager ~]# awk 'BEGIN{info="this is test2010test!";print index(info,"test")?"ok":"not found";}'
ok

length函数(计算长度)
[root@manager ~]# awk 'BEGIN{info="hello";print length(info)}'
5

substr函数(截取字符串)
[root@manager ~]# awk 'BEGIN{info="hello world";print substr(info,4,10)}'
lo world

match函数(正则匹配查找)
[root@manager ~]# awk 'BEGIN{info="hello 2016world";print match(info,/[0-9]+/)?"ok":"none";}'
ok

split函数(字符分割)
[root@manager ~]# awk 'BEGIN{info="hello world";split(info,test);print length(test);for(k in test){print k,test[k];}}'
2
1 hello
2 world

三.一般函数

| 点击这里 | 点击这里 |
| 函数 | 说明 |
| close( Expression ) | 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。 |
| system(Command ) | 执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程。 |
| Expression | getline [ Variable ] | 从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 |
| getline [ Variable ] < Expression | 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 |
| getline [ Variable ] | 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。 |



close函数
[root@manager ~]# awk 'BEGIN{while("head -5 /etc/passwd"|getline){print $0;};close("/etc/passwd");}'
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

getline函数
[root@manager ~]#  awk 'BEGIN{while(getline < "/etc/passwd"){print $0;};close("/etc/passwd");}'


[root@manager ~]#  awk 'BEGIN{print "Enter your name:";getline name;print name;}'
Enter your name:
robin
robin
[root@manager ~]#  awk 'BEGIN{printf "Enter your name:";getline name;print name;}'
Enter your name:robin
robin

[root@manager test7]# awk -F: 'BEGIN{printf "输入用户名: ";getline name;while(getline < "/etc/passwd"){if($1==name) print $0}}'


system函数
[root@manager ~]#  awk 'BEGIN{b=system("ls -l /root");print b;}'
总用量 20
-rw-r--r--  1 root root  135 9月  18 16:14 aa.txt
-rw-------. 1 root root  905 9月   9 06:30 anaconda-ks.cfg
-rw-r--r--. 1 root root 8003 9月   9 06:30 install.log
-rw-r--r--. 1 root root 3384 9月   9 06:30 install.log.syslog
0
[root@manager test7]# awk -F: 'BEGIN{x=system("id robin &>/dev/null");if(x==0){while(getline < "/etc/passwd")if($1=="robin")print $1,$6}}'
robin /home/robin


四.时间函数

| 点击这里 | 点击这里 |
| 函数名 | 说明 |
| mktime( YYYY MM DD HH MM SS[ DST]) | 生成时间格式 |
| strftime([format [, timestamp]]) | 格式化时间输出，将时间戳转为时间字符串 
具体格式，见下表. |
| systime() | 得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 |


创建时间格式
[root@manager ~]# awk 'BEGIN{tstamp=mktime("2001 01 01 12 12 12");print strftime("%c",tstamp);}'
2001年01月01日 星期一 12时12分12秒

[root@manager ~]#  awk 'BEGIN{tstamp1=mktime("2001 01 01 12 12 12");tstamp2=mktime("2001 02 01 0 0 0");print tstamp2-tstamp1;}'
2634468


[root@manager ~]# awk 'BEGIN{tstamp1=mktime("2001 01 01 12 12 12");tstamp2=systime();print tstamp2-tstamp1;}' 
495876393


strftime日期和时间格式说明符


| 格式 | 描述 |
| %a | 星期几的缩写(Sun) |
| %A | 星期几的完整写法(Sunday) |
| %b | 月名的缩写(Oct) |
| %B | 月名的完整写法(October) |
| %c | 本地日期和时间 |
| %d | 十进制日期 |
| %D | 日期 08/20/99 |
| %e | 日期，如果只有一位会补上一个空格 |
| %H | 用十进制表示24小时格式的小时 |
| %I | 用十进制表示12小时格式的小时 |
| %j | 从1月1日起一年中的第几天 |
| %m | 十进制表示的月份 |
| %M | 十进制表示的分钟 |
| %p | 12小时表示法(AM/PM) |
| %S | 十进制表示的秒 |
| %U | 十进制表示的一年中的第几个星期(星期天作为一个星期的开始) |
| %w | 十进制表示的星期几(星期天是0) |
| %W | 十进制表示的一年中的第几个星期(星期一作为一个星期的开始) |
| %x | 重新设置本地日期(08/20/99) |
| %X | 重新设置本地时间(12：00：00) |
| %y | 两位数字表示的年(99) |
| %Y | 当前月份 |
| %Z | 时区(PDT) |
| %% | 百分号(%) |



printf函数
是格式化输出函数, 一般用于向标准输出设备按规定格式输出信息。在编写程序时经常会用到此函数。printf()函数的调用格式为:

%d 十进制有符号整数
%u 十进制无符号整数
%f 浮点数
%s 字符串
%c 单个字符
%p 指针的值
%e 指数形式的浮点数
%x, %X 无符号以十六进制表示的整数
%o 无符号以八进制表示的整数
%g 自动选择合适的表示法
\n 换行
\f 清屏并换页
\r 回车
\t Tab符
\xhh 表示一个ASCII码用16进表示,其中hh是1到2个16进制数

输出样式
	%s是字符类型,%d数值类型
	printf默认是不输出换行的所以要加\n
	10和7是偏移量
	默认是右对齐,所有加个- 就是左对齐,就是把不足的位数用空格填充
	注意:格式与输出列之间要有逗号

[root@manager ~]# awk 'BEGIN{a=16;printf "%-10o\n",a}'
20


1.使用awk打印一个用星号组成金字塔

2.使用awk打印99乘法表

3.输出100-999
1-9 0-9 0-9

4.开两个虚拟机,定时(10分钟)将虚拟机的httpd日志收集到本机,提取,这些httpd日志的 ip  访问时间 浏览器 保存到文件

5.超市


























练习1答案
1. awk -F: '$3>=30&&$3<=40 {print NR, $1}' passwd
2. awk -F: 'NR>=5&&NR<=10 {print NR, $1}' passwd
3. awk -F: 'NR%2!=0 {print}' passwd
4. awk -F: 'NR%2==0 {print}' passwd
5. awk -F: 'NF>5 {print NR}' passwd
6. awk -F: '$3!=$4 {print $3,$4}' passwd
7. seq 100 | awk '$0%7==0 || $0 ~/7/ {print $0}' | head -3
8. awk -F: 'BEGIN{i=0}{sum+=$3;gsum+=$4;i++}END{print i;print sum;print gsum}' /etc/passwd
9. ps aux | awk 'BEGIN{i=0}NR>=2{vsum+=$5;rsum+=$6;i++}END{print vsum/1024"M";print rsum/1024"M";print i}'
练习2:
练习找出普通用户的用户名并统计数量
awk -F: 'BEGIN{i=0} $3>=500 {print $1;i++} END {print i}' /etc/passwd
awk -F: '{if($3==0) print $1"\t"$3"\t""admin";else if($3>=1&&$3<500) print $1,$3,"sysuser";else print $1,$3,"user"}' /etc/passwd
练习打印100以内的偶数
# awk 'BEGIN{i=1;while(i<100) {if (i%2==0) print i;i++}}'

逆序输出每个字段
	达到这样既可
	/bin/bash
	/root
	root
	0
	0
	x
	root


	# awk -F: '{for (x=NF;x>0;x--) print $x}' /etc/passwd

输出样式
	%s是字符类型,%d数值类型
	printf默认是不输出换行的所以要加\n
	10和7是偏移量
	默认是右对齐,所有加个- 就是左对齐,就是把不足的位数用空格填充
	注意:格式与输出列之间要有逗号
	# awk -F: '{printf "%-10s %-10d %s\n",$1,$3,$7}' /etc/passwd

继续解决上一个试做题的格式问题
	# awk -F: '/bash$/{for (x=NF;x>0;x--) printf "%-13s",$x;printf "\n"}' /etc/passwd



使用嵌套的for循环,打印100-999之间的数,个十百位分别用一个for来打印
	# awk 'BEGIN{OFS="";for (i=1;i<=9;i++) {for (j=0;j<=9;j++) {for (n=0;n<=9;n++) print i,j,n}}}'
    打印乘法口诀表
	# cat 99.sh 
	#!/bin/bash
	awk 'BEGIN{
		for(i=1;i<10;i++)
		{
			for(j=1;j<=i;j++)
				printf "%d*%d=%d ",j,i,j*i
			print
		}	

	}'
	# 

    打印金字塔
	# cat jin.sh 
	#!/bin/bash
	awk 'BEGIN{
		num=5
		for(i=1;i<=num;i++)
		{	
			for (n=1;n<=num-i;n++)
				printf "%s"," "
			for (j=1;j<=2*i-1;j++)
		   		printf "%s","*"
			print
		}
	}'



[root@manager ~]# awk '{for(i=1;i<=NF;i++) ary[NR,i]=$i}END{for(j=1;j<=NF;j++){for(k=1;k<=NR;k++)printf ary[k,j]" ";printf "\n"}}' aa.txt 
1 1 1 1 1 
2 2 2 2 2 
3 3 3 3 3 
4 4 4 4 4 
5 5 5 5 5 
[root@manager ~]# cat aa.txt 
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5























